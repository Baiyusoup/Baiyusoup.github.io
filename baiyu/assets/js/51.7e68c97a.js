(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{645:function(_,v,a){"use strict";a.r(v);var t=a(5),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"实现方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现方法"}},[_._v("#")]),_._v(" 实现方法")]),_._v(" "),a("ul",[a("li",[_._v("手工构造词法分析程序：状态转换图表示单词的构成规则")]),_._v(" "),a("li",[_._v("自动生成词法分析程序：正则表达式和有穷自动机。正则表达式是用来表示单词构成模式的表示方法，有穷自动机能对正则表达式表示的字符进行识别")])]),_._v(" "),a("h2",{attrs:{id:"状态转换图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态转换图"}},[_._v("#")]),_._v(" 状态转换图")]),_._v(" "),a("p",[_._v("状态转换图是描述单词构成规则的一种很好的工具。状态转换图是一张有限方向图。")]),_._v(" "),a("ul",[a("li",[_._v("有限个节点，结点称为状态")]),_._v(" "),a("li",[_._v("状态之间用带箭头的弧线连接，称为边")]),_._v(" "),a("li",[_._v("一个初态，至少一个终态")])]),_._v(" "),a("h2",{attrs:{id:"超前搜索技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超前搜索技术"}},[_._v("#")]),_._v(" 超前搜索技术")]),_._v(" "),a("p",[_._v("这个东西是为了处理双界符，比如读到 > 时，有可能就它一个，也有可能是 >>，这时就需要")]),_._v(" "),a("h2",{attrs:{id:"正则表达式和有穷自动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式和有穷自动机"}},[_._v("#")]),_._v(" 正则表达式和有穷自动机")]),_._v(" "),a("p",[_._v("字的前缀是指从字的开头取0个或多个符号得到的符号串，后缀同理。字的子串就是从字中删除任意前缀或后缀后得到的符号串")]),_._v(" "),a("p",[_._v("正则表达式：可以描述所有通过某个字母表上的符号串集合应用并、连接和闭包运算而得到的语言，是一种描述字符串构成模式的方法")]),_._v(" "),a("h3",{attrs:{id:"有穷自动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有穷自动机"}},[_._v("#")]),_._v(" 有穷自动机")]),_._v(" "),a("p",[_._v("有穷自动机是具有离散输入和输出的系统的一种数学模型，系统可以处于有限个状态中的任何一个状态。实际上是状态转换图的形式化表示。")]),_._v(" "),a("h4",{attrs:{id:"确定的有穷自动机dfa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#确定的有穷自动机dfa"}},[_._v("#")]),_._v(" 确定的有穷自动机DFA")]),_._v(" "),a("p",[_._v("是指在一个状态输入一个符号，状态转换到唯一的下一个状态。DFA是一个由五元组定义的数学模型\n$$\nM = (S, \\ast, \\above, S_0, F)\n$$")]),_._v(" "),a("p",[_._v("有三种表示方式：状态转换函数表示；状态转换图表示；状态转换表")]),_._v(" "),a("p",[_._v("DFA能识别某符号串a是指对于")]),_._v(" "),a("p",[_._v("如果DFA的初态又是终态的话，则称该DFA可识别空字")]),_._v(" "),a("h4",{attrs:{id:"不确定的有穷自动机nfa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不确定的有穷自动机nfa"}},[_._v("#")]),_._v(" 不确定的有穷自动机NFA")]),_._v(" "),a("p",[_._v("是指在一个状态下输入一个符号，可能有两个或两个及以上的后继状态。在某种状态下，不读入任何符号就有可能转入另一个或多个状态，也就是可以将ε当作一个假想的输入字母。")]),_._v(" "),a("p",[_._v("NFA的不确定性反映在NFA的定义中，就是转换函数是一对多的\n反映在状态转换图中，就是从一个状态出发可能有多于一条标记相同的弧转移到不同的后继状态\n反映在状态转换表中，就是M[i, a]的值不是单一状态的")]),_._v(" "),a("h4",{attrs:{id:"nfa的确定化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nfa的确定化"}},[_._v("#")]),_._v(" NFA的确定化")]),_._v(" "),a("p",[_._v("DFA和NFA的区别")]),_._v(" "),a("ol",[a("li",[_._v("DFA任何状态之间都没有ε转换，即没有任何状态可以不进行输入符号的匹配就直接进入下一个状态")]),_._v(" "),a("li",[_._v("DFA对任何状态s和任何输入符号a，最多只有一条标记为a的边离开s")]),_._v(" "),a("li",[_._v("DFA的初态是唯一的，NFA的初态是一个集合")])]),_._v(" "),a("p",[_._v("两个有穷自动机的等价是指对任何两个有穷自动机M和M'，如果L(M)=L(M')，则称M和M'是等价的")]),_._v(" "),a("p",[_._v("对于每一个NFA M，一定存在一个DFA M'，使得L(M)=L(M')")]),_._v(" "),a("p",[_._v("从NFA构造等价的DFA的方法很多，常用的是子集法：DFA的每一个状态对应于NFA的一组状态，用DFA的一个状态去记录在NFA中读入一个输入符号后可能达到的状态集合。")]),_._v(" "),a("h5",{attrs:{id:"相关算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关算法"}},[_._v("#")]),_._v(" 相关算法")]),_._v(" "),a("p",[_._v("与状态集合I有关的运算：")]),_._v(" "),a("ol",[a("li",[_._v("状态集合I的"),a("code",[_._v("ε-闭包")]),_._v("表示为"),a("code",[_._v("ε_Closure(I)")]),_._v("，定义由下面两条规则构成的集合：\n"),a("ol",[a("li",[_._v("若q属于I，则q∈"),a("code",[_._v("ε_Closure(I)")])]),_._v(" "),a("li",[_._v("若q属于I，设从q出发经过任意条ε弧而能到达的状态为q',则 q' ∈ "),a("code",[_._v("ε_Closure(I)")])])])]),_._v(" "),a("li",[_._v("状态集合I的a弧转换表示Ia，定义为Ia = "),a("code",[_._v("ε_Closure(move(I, a))")]),_._v("，其中move(I, a)表示从I中任一状态出发经过一条a弧到达的集合")])]),_._v(" "),a("p",[_._v("确定化步骤")]),_._v(" "),a("ol",[a("li",[a("p",[_._v("增加X和Y两个状态，使之成为新的唯一初态和终态，从X引ε弧到原始初态，从原始终态引ε弧到状态Y")])]),_._v(" "),a("li",[a("p",[_._v("对状态图进一步改造")])]),_._v(" "),a("li",[a("p",[_._v("对改造后的NFA使用子集法进行确定化，算法如下:\n1.")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);