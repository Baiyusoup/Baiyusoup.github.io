(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{639:function(v,_,t){"use strict";t.r(_);var a=t(5),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),t("p",[v._v("是对程序进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。")]),v._v(" "),t("p",[v._v("等价：不改变程序的运行结果\n有效：目标代码运行时间短，占用存储空间小")]),v._v(" "),t("p",[v._v("目的：产生更高效的代码")]),v._v(" "),t("p",[v._v("删除公共子表达式\n复写传播：经过删除公共子表达式后，会有些等价变量的引用")]),v._v(" "),t("p",[v._v("删除无用代码\n复写传播的目的是是某些变量的赋值变为无效，经过复写传播优化之后，会有些无用的赋值语句，可以删除，在离开所在基本块之后，也不会再被引用的变量，也可以删除掉。\n代数恒等换：简单代数变换、强度削弱、合并已知量、复杂的代数变换")]),v._v(" "),t("p",[v._v("局部优化\n循环优化\n全局优化")]),v._v(" "),t("h2",{attrs:{id:"循环优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#循环优化"}},[v._v("#")]),v._v(" 循环优化")]),v._v(" "),t("h4",{attrs:{id:"代码外提"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码外提"}},[v._v("#")]),v._v(" 代码外提")]),v._v(" "),t("p",[v._v("将循环不变运算放到循环外面，并创建一个前置节点的基本块，放这些不变运算。")]),v._v(" "),t("ol",[t("li",[v._v("当把一不变运算外提到循环前置结点时，要求该不变运算所在节点是循环所有出口节点的必经节点。")]),v._v(" "),t("li",[v._v("当把循环中的不变运算x=y op z外提时，要求循环中的其他地方不再有x的定值点。")])]),v._v(" "),t("h4",{attrs:{id:"强度削弱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强度削弱"}},[v._v("#")]),v._v(" 强度削弱")]),v._v(" "),t("p",[v._v("将乘除变为加减")]),v._v(" "),t("h4",{attrs:{id:"删除归纳变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除归纳变量"}},[v._v("#")]),v._v(" 删除归纳变量")]),v._v(" "),t("p",[v._v("如果循环中对变量I只有唯一的形如I=I+C或I-C，C是循环不变量，则称I为循环中的基本归纳变量，如果J是循环中的赋值总可以化为I的同一线性函数，那么J为归纳变量，同时称J于I同族。如果在循环中，有两个或更多个同族的归纳变量，可以只留一个来代替基本归纳变量进行循环的控制，删除其余的归纳变量。")]),v._v(" "),t("h2",{attrs:{id:"基本块优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本块优化"}},[v._v("#")]),v._v(" 基本块优化")]),v._v(" "),t("p",[v._v("基本块：程序中一顺序执行语句序列，其中只有一个入口和一个出口。入口就是其中第一个语句，出口就是其中最后一个语句。")]),v._v(" "),t("p",[v._v("定值和引用：对三地址语句x=y+z称对x"),t("strong",[v._v("定值")]),v._v("并引用y和z\n活跃：指如果在程序中（包括本基本块和其他基本块中）它的值在该点以后被引用")]),v._v(" "),t("p",[v._v("基本块划分算法：")]),v._v(" "),t("ol",[t("li",[v._v("找出中间语言程序中各个基本块的入口语句\n"),t("ol",[t("li",[v._v("程序的第一个语句")]),v._v(" "),t("li",[v._v("能有条件转移语句或无条件转移语句转移到的语句")]),v._v(" "),t("li",[v._v("紧跟在条件转移语句后面的语句")])])]),v._v(" "),t("li",[v._v("对以上求出每个入口语句，确定其所属的基本块\n"),t("ol",[t("li",[v._v("它是由该入口语句到下一入口语句（不含该入口如语句）")]),v._v(" "),t("li",[v._v("或到一转移语句（包含该转移语句）")]),v._v(" "),t("li",[v._v("或一停语句（包括该停语句）\n之间的语句序列组成的。")])])]),v._v(" "),t("li",[v._v("凡未被纳入基本块中的语句，可以从程序中删除。")])]),v._v(" "),t("p",[v._v("优化措施：合并已知量、删除公共子表达式、删除无用代码")])])}),[],!1,null,null,null);_.default=s.exports}}]);